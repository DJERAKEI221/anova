# Création d'identifiants "sujets" artificiels par (fertilisant, variete, rang)
# pour simuler des mesures répétées comme dans l'exemple DABIRE
group_by(fertilisant, variete, periode) %>%
arrange(fertilisant, variete, periode, .by_group = TRUE) %>%
mutate(rang = row_number()) %>%
ungroup() %>%
mutate(
id = interaction(fertilisant, variete, rang, drop = TRUE),
id = factor(id)
)
# --- ANOVA à mesures répétées avec afex::aov_car -------------------------
# On fixe le type de sommes de carrés à III (classique en présence d'interactions)
afex::afex_options(type = 3)
# Ajustement du modèle :
# - hauteur : variable dépendante
# - fertilisant * variete : effets fixes inter-sujets et leur interaction
# - Error(id / periode) : structure de mesures répétées (effet de periode imbriqué dans id)
# - na.rm = TRUE : les observations manquantes (périodes non observées pour certains individus)
#   sont retirées de l'analyse, comme suggéré par le message d'erreur d'afex.
anova_rm <- afex::aov_car(
hauteur ~ fertilisant * variete + Error(id / periode),
data  = d,
na.rm = TRUE
)
# Tableau ANOVA "propre" (nice) :
# - fournit F, p-value, et η² partiel (pes) pour chaque effet
tab_rm <- nice(anova_rm, es = "pes")
knitr::kable(
tab_rm,
caption = "ANOVA à mesures répétées (afex::aov_car) : effets de fertilisant, variété, période et interactions, avec η² partiel."
)
En résumé, la hauteur dépend significativement du **fertilisant** et de la **variété**, ainsi que de la **période** de mesure, avec une interaction significative entre **variété et période** ; les interactions impliquant le fertilisant ne sont pas significatives.
# Résumé complet du modèle :
# - inclut le test de Mauchly (sphéricité)
# - et les corrections GG / HF si nécessaire
summary(anova_rm)
Les tests de **Mauchly** ne sont pas significatifs, ce qui indique que l’hypothèse de sphéricité est raisonnable ; les corrections de Greenhouse–Geisser et Huynh–Feldt confirment la significativité de l’effet de la **période** et de l’interaction **variété × période**, tandis que les termes avec le fertilisant restent non significatifs.
# On extrait les résidus du modèle sous-jacent (lm) contenu dans l'objet afex
res <- residuals(anova_rm$lm)
# Affichage côte à côte :
# - Q-Q plot : vérification de l'alignement des résidus sur la droite théorique
# - Histogramme : forme globale (approximation gaussienne attendue)
par(mfrow = c(1, 2))
qqnorm(res, main = "Q-Q des résidus"); qqline(res)
hist(res, breaks = 15, main = "Distribution des résidus", xlab = "Résidus")
par(mfrow = c(1, 1))
# Test formel de normalité (Shapiro-Wilk)
shapiro_res <- shapiro.test(res)
shapiro_res
# Agrégation : moyenne de hauteur par id, fertilisant, variété
d_mean <- d %>%
group_by(id, fertilisant, variete) %>%
summarise(hauteur_moy = mean(hauteur, na.rm = TRUE), .groups = "drop")
# Test de Levene sur les variances de hauteur moyenne entre combinaisons fertilisant × variété
lev <- car::leveneTest(hauteur_moy ~ fertilisant * variete, data = d_mean)
# Mise en forme d'un tableau lisible
lev_df <- as.data.frame(lev)
lev_df <- cbind(Source = rownames(lev_df), lev_df)
rownames(lev_df) <- NULL
names(lev_df) <- c("Source", "Ddl", "F", "p-value")
lev_df[["p-value"]] <- ifelse(is.na(lev_df[["p-value"]]), "—", format.pval(lev_df[["p-value"]], digits = 3))
lev_df[["F"]] <- ifelse(is.na(lev_df[["F"]]), "—", format(round(lev_df[["F"]], 4), nsmall = 4))
lev_df[is.na(lev_df)] <- "—"
knitr::kable(
lev_df,
align = c("l", "r", "r", "r"),
caption = "Test de Levene sur la hauteur moyenne (homogénéité des variances entre groupes de fertilisant et de variété)."
)
# Moyennes marginales (effet global de fertilisant × variété, toutes périodes confondues)
emm_gv <- emmeans(anova_rm, ~ fertilisant * variete)
# Extraction sous forme de data.frame et arrondi pour la présentation
emm_gv_df <- summary(emm_gv) %>% as.data.frame()
emm_gv_df <- emm_gv_df %>%
mutate(
emmean   = round(emmean, 2),
SE       = round(SE, 3),
lower.CL = round(lower.CL, 2),
upper.CL = round(upper.CL, 2)
)
names(emm_gv_df) <- c("Fertilisant", "Variété", "Moyenne", "ESM", "Ddl", "IC inf.", "IC sup.")
knitr::kable(
emm_gv_df[, c("Fertilisant", "Variété", "Moyenne", "ESM", "IC inf.", "IC sup.")],
align = c("l", "l", "r", "r", "r", "r"),
caption = "Moyennes marginales (et IC 95 %) pour fertilisant × variété (toutes périodes confondues)."
)
# Comparaisons toutes paires de combinaisons fertilisant × variété (corrigées de Tukey)
ph_gv <- pairs(emm_gv, adjust = "tukey") %>% as.data.frame()
pval <- ph_gv$p.value
ph_gv <- ph_gv %>%
mutate(
estimate = round(estimate, 3),
SE       = round(SE, 3),
t.ratio  = round(t.ratio, 2),
signif   = case_when(
pval < 0.001 ~ "***",
pval < 0.01  ~ "**",
pval < 0.05  ~ "*",
TRUE         ~ ""
),
p.value = format.pval(p.value, digits = 3, eps = 0.001)
)
names(ph_gv) <- c("Contraste", "Différence", "ESM", "Ddl", "t", "p-value", "Signif.")
knitr::kable(
ph_gv,
align = c("l", "r", "r", "r", "r", "r", "c"),
caption = "Comparaisons post-hoc Tukey : fertilisant × variété (toutes périodes confondues). * p < 0,05 ; ** p < 0,01 ; *** p < 0,001."
)
# Effets de fertilisant × variété examinés séparément pour chaque période (T1, T2, T3, T4)
emm_per <- emmeans(anova_rm, ~ fertilisant * variete | periode)
ph_per <- pairs(emm_per, adjust = "tukey") %>% as.data.frame()
pval_per <- ph_per$p.value
ph_per <- ph_per %>%
mutate(
estimate = round(estimate, 3),
SE       = round(SE, 3),
t.ratio  = round(t.ratio, 2),
signif   = case_when(
pval_per < 0.001 ~ "***",
pval_per < 0.01  ~ "**",
pval_per < 0.05  ~ "*",
TRUE             ~ ""
),
p.value = format.pval(p.value, digits = 3, eps = 0.001)
)
names(ph_per) <- c("Contraste", "Différence", "ESM", "Ddl", "t", "p-value", "Signif.", "Période")
knitr::kable(
ph_per[, c("Période", "Contraste", "Différence", "ESM", "t", "p-value", "Signif.")],
align = c("l", "l", "r", "r", "r", "r", "c"),
caption = "Comparaisons post-hoc Tukey par période. * p < 0,05 ; ** p < 0,01 ; *** p < 0,001."
)
library(tidyverse)
library(readxl)
library(knitr)
if (!requireNamespace("nortest", quietly = TRUE)) install.packages("nortest", repos = "https://cloud.r-project.org", quiet = TRUE)
library(nortest)
library(rstatix)
library(ggpubr)
library(car)
# Import des mêmes données que précédemment
d2 <- read_excel("donnees/donnees.xlsx")
# Conversion des virgules décimales en points et mise en forme des facteurs
d2$hauteur <- as.numeric(gsub(",", ".", as.character(d2$hauteur)))
d2 <- d2 %>%
mutate(
fertilisant = factor(fertilisant),               # Ma, Ca, An
variete     = factor(variete),                   # Var1, Var2
periode     = factor(periode, levels = c("T1","T2","T3","T4"))
)
# Création d'IDs artificiels par (fertilisant, variete, periode)
d2_id <- d2 %>%
group_by(fertilisant, variete, periode) %>%
arrange(No, .by_group = TRUE) %>%
mutate(rang = row_number()) %>%
ungroup() %>%
mutate(id = interaction(fertilisant, variete, rang, drop = TRUE))
# Passage au format large : une ligne = un "sujet", colonnes t1..t4
base <- d2_id %>%
mutate(
numeromesure = dplyr::recode(
as.character(periode),
"T1" = "t1",
"T2" = "t2",
"T3" = "t3",
"T4" = "t4"
)
) %>%
select(id, fertilisant, variete, numeromesure, hauteur) %>%
tidyr::pivot_wider(
names_from  = numeromesure,
values_from = hauteur
) %>%
arrange(id)
# Matrice de réponses hauteur (t1..t4) et facteurs
base$hauteur    <- as.matrix(base[, c("t1","t2","t3","t4")])
base$fertilisant <- factor(base$fertilisant)
base$variete     <- factor(base$variete)
attach(base)
mod.hauteur.fertilisant <- lm(hauteur ~ fertilisant)
H_fert <- summary(aov(mod.hauteur.fertilisant))
H_fert
LM_fert <- summary(mod.hauteur.fertilisant)
LM_fert
mod.hauteur.variete <- lm(hauteur ~ variete)
H_var <- summary(aov(mod.hauteur.variete))
H_var
LM_var <- summary(mod.hauteur.variete)
LM_var
mod.hauteur.interaction <- lm(hauteur ~ variete * fertilisant)
H_int <- summary(aov(mod.hauteur.interaction))
H_int
fact.temps <- data.frame(TEMPS = as.factor(1:4))
mod.hauteur.tps.interaction <- Anova(
mod.hauteur.interaction,
idata   = fact.temps,
idesign = ~ TEMPS,
type    = "III",
test    = "Wilks"
)
summary(mod.hauteur.tps.interaction)
library(tidyverse)
library(knitr)
if (!requireNamespace("gtsummary", quietly = TRUE)) install.packages("gtsummary", repos = "https://cloud.r-project.org", quiet = TRUE)
library(gtsummary)
# --- Import : plan = mesures répétées T1–T4 pour Var1 et Var2 (colonnes : fertilisant, variete, periode, hauteur) ---
if (!requireNamespace("readxl", quietly = TRUE)) install.packages("readxl", repos = "https://cloud.r-project.org", quiet = TRUE)
library(readxl)
d <- read_excel("donnees/donnees.xlsx")
# Hauteur en numérique (virgule décimale gérée)
d$hauteur <- as.numeric(gsub(",", ".", as.character(d$hauteur)))
# Identifiant sujet : un id par plante (même id pour les 4 périodes d'une même plante)
if (!"id" %in% names(d)) {
d <- d %>%
arrange(fertilisant, variete, periode) %>%
group_by(fertilisant, variete, periode) %>%
mutate(within_subj = row_number()) %>%
ungroup() %>%
mutate(id = paste0(as.character(fertilisant), "_", as.character(variete), "_", within_subj))
}
# Facteurs
d <- d %>%
mutate(
periode     = factor(as.character(periode), levels = c("T1", "T2", "T3", "T4")),
fertilisant = factor(fertilisant, levels = c("Ma", "Ca", "An")),
variete     = factor(variete),
id          = factor(id)
)
# --- Aperçu du jeu de données (format long) ---
d %>%
tbl_summary(include = c(fertilisant, variete, periode, hauteur), statistic = list(hauteur ~ "{mean} ({sd})"), label = list(hauteur ~ "Hauteur")) %>%
modify_caption("Résumé descriptif des variables (fertilisant, variété, période, hauteur)")
# --- Effectifs : nombre d'observations et de sujets ---
n_obs   <- nrow(d)
n_sujets <- n_distinct(d$id)
# Répartition par fertilisant et variété (nombre de sujets uniques)
sujets_uniq <- d %>% distinct(id, fertilisant, variete)
sujets_uniq %>%
tbl_cross(row = fertilisant, col = variete, margin = "row", percent = "none") %>%
modify_caption("Nombre de sujets (plantes) par fertilisant (terreau) et variété")
cat("\n**Total :**", n_obs, "observations,", n_sujets, "sujets.\n")
# --- Résumé global de la variable hauteur ---
hauteur_num <- as.numeric(as.character(d$hauteur))
resum_global <- tibble(
Variable = "Hauteur",
n = sum(!is.na(hauteur_num)),
`Moyenne (ET)` = sprintf("%.2f (%.2f)", mean(hauteur_num, na.rm = TRUE), sd(hauteur_num, na.rm = TRUE)),
Min = sprintf("%.2f", min(hauteur_num, na.rm = TRUE)),
Max = sprintf("%.2f", max(hauteur_num, na.rm = TRUE))
)
knitr::kable(resum_global, caption = "Résumé global de la variable hauteur")
# --- Résumé de la hauteur par fertilisant, par variété et par période ---
resum_grp <- d %>% group_by(fertilisant) %>% summarise(n = n(), `Moyenne (ET)` = sprintf("%.2f (%.2f)", mean(hauteur, na.rm = TRUE), sd(hauteur, na.rm = TRUE)), .groups = "drop")
resum_var <- d %>% group_by(variete) %>% summarise(n = n(), `Moyenne (ET)` = sprintf("%.2f (%.2f)", mean(hauteur, na.rm = TRUE), sd(hauteur, na.rm = TRUE)), .groups = "drop")
resum_per <- d %>% group_by(periode) %>% summarise(n = n(), `Moyenne (ET)` = sprintf("%.2f (%.2f)", mean(hauteur, na.rm = TRUE), sd(hauteur, na.rm = TRUE)), .groups = "drop")
knitr::kable(resum_grp, caption = "Hauteur : moyenne (ET) par fertilisant (terreau)")
knitr::kable(resum_var, caption = "Hauteur : moyenne (ET) par variété")
knitr::kable(resum_per, caption = "Hauteur : moyenne (ET) par période")
# --- Tableau croisé fertilisant × variété × période : moyenne (ET) ---
d %>%
mutate(fertilisant_variete = paste(as.character(fertilisant), as.character(variete), sep = " × ")) %>%
tbl_strata(
strata = fertilisant_variete,
.tbl_fun = ~ tbl_summary(.x, by = periode, include = hauteur, statistic = list(hauteur ~ "{mean} ({sd})"), label = list(hauteur ~ "Hauteur")),
.header = "**{strata}**",
.combine_with = "tbl_stack"
) %>%
modify_caption("Moyennes et écarts-types de la hauteur par fertilisant, variété et période")
ggplot(d, aes(x = periode, y = hauteur, fill = periode)) +
geom_boxplot(alpha = 0.7) +
scale_fill_brewer(palette = "Pastel1") +
labs(x = "Période", y = "Hauteur") +
theme_minimal(base_size = 12) +
theme(legend.position = "none")
ggplot(d, aes(x = fertilisant, y = hauteur, fill = fertilisant)) +
geom_boxplot(alpha = 0.7) +
scale_fill_brewer(palette = "Set1") +
labs(x = "Fertilisant (terreau)", y = "Hauteur") +
theme_minimal(base_size = 12) +
theme(legend.position = "none")
d %>%
group_by(fertilisant, variete, periode) %>%
summarise(hauteur_moy = mean(hauteur, na.rm = TRUE), .groups = "drop") %>%
ggplot(aes(x = periode, y = hauteur_moy, colour = fertilisant, group = fertilisant)) +
geom_line(linewidth = 1) +
geom_point(size = 3) +
facet_wrap(~ variete, ncol = 2) +
scale_color_brewer(palette = "Set1") +
labs(
x = "Période",
y = "Hauteur (moyenne)",
colour = "Fertilisant (terreau)"
) +
theme_minimal(base_size = 12) +
theme(
legend.position = "bottom",
strip.background = element_rect(fill = "grey92", colour = NA)
)
library(tidyverse)
library(emmeans)
library(car)
if (!requireNamespace("afex", quietly = TRUE)) install.packages("afex", repos = "https://cloud.r-project.org", quiet = TRUE)
library(afex)
if (!requireNamespace("gtsummary", quietly = TRUE)) install.packages("gtsummary", repos = "https://cloud.r-project.org", quiet = TRUE)
library(gtsummary)
library(knitr)
# --- Import : plan = mesures répétées T1–T4 pour Var1 et Var2, dans chaque fertilisant ---
if (!requireNamespace("readxl", quietly = TRUE)) install.packages("readxl", repos = "https://cloud.r-project.org", quiet = TRUE)
library(readxl)
d <- read_excel("donnees/donnees.xlsx")
d$hauteur <- as.numeric(gsub(",", ".", as.character(d$hauteur)))
d <- d %>%
mutate(
periode     = factor(as.character(periode), levels = c("T1", "T2", "T3", "T4")),
fertilisant = factor(fertilisant, levels = c("Ma", "Ca", "An")),
variete     = factor(variete)
) %>%
# Création d'identifiants "sujets" artificiels par (fertilisant, variete, rang)
# pour simuler des mesures répétées comme dans l'exemple DABIRE
group_by(fertilisant, variete, periode) %>%
arrange(fertilisant, variete, periode, .by_group = TRUE) %>%
mutate(rang = row_number()) %>%
ungroup() %>%
mutate(
id = interaction(fertilisant, variete, rang, drop = TRUE),
id = factor(id)
)
# --- ANOVA à mesures répétées avec afex::aov_car -------------------------
# On fixe le type de sommes de carrés à III (classique en présence d'interactions)
afex::afex_options(type = 3)
# Ajustement du modèle :
# - hauteur : variable dépendante
# - fertilisant * variete : effets fixes inter-sujets et leur interaction
# - Error(id / periode) : structure de mesures répétées (effet de periode imbriqué dans id)
# - na.rm = TRUE : les observations manquantes (périodes non observées pour certains individus)
#   sont retirées de l'analyse, comme suggéré par le message d'erreur d'afex.
anova_rm <- afex::aov_car(
hauteur ~ fertilisant * variete + Error(id / periode),
data  = d,
na.rm = TRUE
)
# Tableau ANOVA "propre" (nice) :
# - fournit F, p-value, et η² partiel (pes) pour chaque effet
tab_rm <- nice(anova_rm, es = "pes")
knitr::kable(
tab_rm,
caption = "ANOVA à mesures répétées (afex::aov_car) : effets de fertilisant, variété, période et interactions, avec η² partiel."
)
# Résumé complet du modèle :
# - inclut le test de Mauchly (sphéricité)
# - et les corrections GG / HF si nécessaire
summary(anova_rm)
# On extrait les résidus du modèle sous-jacent (lm) contenu dans l'objet afex
res <- residuals(anova_rm$lm)
# Affichage côte à côte :
# - Q-Q plot : vérification de l'alignement des résidus sur la droite théorique
# - Histogramme : forme globale (approximation gaussienne attendue)
par(mfrow = c(1, 2))
qqnorm(res, main = "Q-Q des résidus"); qqline(res)
hist(res, breaks = 15, main = "Distribution des résidus", xlab = "Résidus")
par(mfrow = c(1, 1))
# Test formel de normalité (Shapiro-Wilk)
shapiro_res <- shapiro.test(res)
shapiro_res
# Agrégation : moyenne de hauteur par id, fertilisant, variété
d_mean <- d %>%
group_by(id, fertilisant, variete) %>%
summarise(hauteur_moy = mean(hauteur, na.rm = TRUE), .groups = "drop")
# Test de Levene sur les variances de hauteur moyenne entre combinaisons fertilisant × variété
lev <- car::leveneTest(hauteur_moy ~ fertilisant * variete, data = d_mean)
# Mise en forme d'un tableau lisible
lev_df <- as.data.frame(lev)
lev_df <- cbind(Source = rownames(lev_df), lev_df)
rownames(lev_df) <- NULL
names(lev_df) <- c("Source", "Ddl", "F", "p-value")
lev_df[["p-value"]] <- ifelse(is.na(lev_df[["p-value"]]), "—", format.pval(lev_df[["p-value"]], digits = 3))
lev_df[["F"]] <- ifelse(is.na(lev_df[["F"]]), "—", format(round(lev_df[["F"]], 4), nsmall = 4))
lev_df[is.na(lev_df)] <- "—"
knitr::kable(
lev_df,
align = c("l", "r", "r", "r"),
caption = "Test de Levene sur la hauteur moyenne (homogénéité des variances entre groupes de fertilisant et de variété)."
)
# Moyennes marginales (effet global de fertilisant × variété, toutes périodes confondues)
emm_gv <- emmeans(anova_rm, ~ fertilisant * variete)
# Extraction sous forme de data.frame et arrondi pour la présentation
emm_gv_df <- summary(emm_gv) %>% as.data.frame()
emm_gv_df <- emm_gv_df %>%
mutate(
emmean   = round(emmean, 2),
SE       = round(SE, 3),
lower.CL = round(lower.CL, 2),
upper.CL = round(upper.CL, 2)
)
names(emm_gv_df) <- c("Fertilisant", "Variété", "Moyenne", "ESM", "Ddl", "IC inf.", "IC sup.")
knitr::kable(
emm_gv_df[, c("Fertilisant", "Variété", "Moyenne", "ESM", "IC inf.", "IC sup.")],
align = c("l", "l", "r", "r", "r", "r"),
caption = "Moyennes marginales (et IC 95 %) pour fertilisant × variété (toutes périodes confondues)."
)
# Comparaisons toutes paires de combinaisons fertilisant × variété (corrigées de Tukey)
ph_gv <- pairs(emm_gv, adjust = "tukey") %>% as.data.frame()
pval <- ph_gv$p.value
ph_gv <- ph_gv %>%
mutate(
estimate = round(estimate, 3),
SE       = round(SE, 3),
t.ratio  = round(t.ratio, 2),
signif   = case_when(
pval < 0.001 ~ "***",
pval < 0.01  ~ "**",
pval < 0.05  ~ "*",
TRUE         ~ ""
),
p.value = format.pval(p.value, digits = 3, eps = 0.001)
)
names(ph_gv) <- c("Contraste", "Différence", "ESM", "Ddl", "t", "p-value", "Signif.")
knitr::kable(
ph_gv,
align = c("l", "r", "r", "r", "r", "r", "c"),
caption = "Comparaisons post-hoc Tukey : fertilisant × variété (toutes périodes confondues). * p < 0,05 ; ** p < 0,01 ; *** p < 0,001."
)
# Effets de fertilisant × variété examinés séparément pour chaque période (T1, T2, T3, T4)
emm_per <- emmeans(anova_rm, ~ fertilisant * variete | periode)
ph_per <- pairs(emm_per, adjust = "tukey") %>% as.data.frame()
pval_per <- ph_per$p.value
ph_per <- ph_per %>%
mutate(
estimate = round(estimate, 3),
SE       = round(SE, 3),
t.ratio  = round(t.ratio, 2),
signif   = case_when(
pval_per < 0.001 ~ "***",
pval_per < 0.01  ~ "**",
pval_per < 0.05  ~ "*",
TRUE             ~ ""
),
p.value = format.pval(p.value, digits = 3, eps = 0.001)
)
names(ph_per) <- c("Contraste", "Différence", "ESM", "Ddl", "t", "p-value", "Signif.", "Période")
knitr::kable(
ph_per[, c("Période", "Contraste", "Différence", "ESM", "t", "p-value", "Signif.")],
align = c("l", "l", "r", "r", "r", "r", "c"),
caption = "Comparaisons post-hoc Tukey par période. * p < 0,05 ; ** p < 0,01 ; *** p < 0,001."
)
library(tidyverse)
library(readxl)
library(knitr)
if (!requireNamespace("nortest", quietly = TRUE)) install.packages("nortest", repos = "https://cloud.r-project.org", quiet = TRUE)
library(nortest)
library(rstatix)
library(ggpubr)
library(car)
# Import des mêmes données que précédemment
d2 <- read_excel("donnees/donnees.xlsx")
# Conversion des virgules décimales en points et mise en forme des facteurs
d2$hauteur <- as.numeric(gsub(",", ".", as.character(d2$hauteur)))
d2 <- d2 %>%
mutate(
fertilisant = factor(fertilisant),               # Ma, Ca, An
variete     = factor(variete),                   # Var1, Var2
periode     = factor(periode, levels = c("T1","T2","T3","T4"))
)
# Création d'IDs artificiels par (fertilisant, variete, periode)
d2_id <- d2 %>%
group_by(fertilisant, variete, periode) %>%
arrange(No, .by_group = TRUE) %>%
mutate(rang = row_number()) %>%
ungroup() %>%
mutate(id = interaction(fertilisant, variete, rang, drop = TRUE))
# Passage au format large : une ligne = un "sujet", colonnes t1..t4
base <- d2_id %>%
mutate(
periode_mesure = dplyr::recode(
as.character(periode),
"T1" = "t1",
"T2" = "t2",
"T3" = "t3",
"T4" = "t4"
)
) %>%
select(id, fertilisant, variete, periode_mesure, hauteur) %>%
tidyr::pivot_wider(
names_from  = periode_mesure,
values_from = hauteur
) %>%
arrange(id)
# Matrice de réponses hauteur (t1..t4) et facteurs
base$hauteur    <- as.matrix(base[, c("t1","t2","t3","t4")])
base$fertilisant <- factor(base$fertilisant)
base$variete     <- factor(base$variete)
attach(base)
mod.hauteur.fertilisant <- lm(hauteur ~ fertilisant)
H_fert <- summary(aov(mod.hauteur.fertilisant))
H_fert
LM_fert <- summary(mod.hauteur.fertilisant)
LM_fert
mod.hauteur.variete <- lm(hauteur ~ variete)
H_var <- summary(aov(mod.hauteur.variete))
H_var
LM_var <- summary(mod.hauteur.variete)
LM_var
mod.hauteur.interaction <- lm(hauteur ~ variete * fertilisant)
H_int <- summary(aov(mod.hauteur.interaction))
H_int
fact.temps <- data.frame(TEMPS = as.factor(1:4))
mod.hauteur.tps.interaction <- Anova(
mod.hauteur.interaction,
idata   = fact.temps,
idesign = ~ TEMPS,
type    = "III",
test    = "Wilks"
)
summary(mod.hauteur.tps.interaction)
